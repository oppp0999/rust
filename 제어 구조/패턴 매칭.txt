Rust의 match 구조는 C의 switch 구조의 일반화되고, 깔끔한 버전이다. 값과 다수의 분기로 구성되고, 각 분기는 패턴으로 이름지어지고, 코드는 값과 각 패턴을 순서대로 하나라도 일치할 때까지 비교한다. 일치된 패턴은 대응하는 분기를 실행한다.

match my_number {
  0     => println("zero"),
  1 | 2 => println("one or two"),
  3..10 => println("three to ten"),
  _     => println("something else")
}
C와는 다르게, 분기 사이에 "내려가기(falling through)"가 없다. 단지 하나의 분기만 실행하고, 분기가 끝났을 때 명시적으로 break를 이용해 구조를 빠져나갈 필요가 없다.

A match 분기는 패턴, 화살표 =>, 액션 (표현식)순으로 구성된다. 리터럴은 유효한 패턴이고, 자신의 값만 일치한다. 모든 패턴이 동일한 변수의 집합과 결합한다면 하나의 분기는 파이프 연산자 (|)로 결합하여 다수의 서로 다른 패턴과 대응할 수도 있다. 숫자 리터럴 범위 패턴은 M..N처럼 두개의 점을 이용해 표현한다. 밑줄(_)은 어떠한 하나의 값에 대응하는 와일드카드 패턴이다. 별표(*)는 enum variant 에서 하나 혹은 여러 필드와 일치하는 독특한 와일드카드이다.

매칭된 분기에 있는 패턴 뒤에 두꺼운 화살표 =>가 따라오고, 그 다음은 평가되는 표현식이다. 각 케이스는 쉼표로 구분된다. 쉼표는 선택적이고, 각 케이스에 대해 블록 표현식을 사용하는 것보다 종종 편리하다.

match my_number {
  0 => { println("zero") }
  _ => { println("something else") }
}
match 구조는 소모적(모든 가능한 경우를 다루는 분기를 가지고 있음) 이어야 한다. 예를 들어, 와일드카드 패턴을 가지고 있는 분기가 생략되었다면 타입 판별기는 앞의 예제를 거부할 것이다.

패턴 매칭의 강력한 응용은 디스트럭처링이다. 이름을 데이터 타입의 내용에 대응하기위해 매칭하는 것.

노트: 다음의 코드는 섹션 5.3에서 설명되는 튜플((float, float))을 사용한다. 이제 아이템의 목록으로서의 튜플을 떠올릴 수 있다.

use std::float;
use std::num::atan;
fn angle(vector: (float, float)) -> float {
    let pi = float::consts::pi;
    match vector {
      (0f, y) if y < 0f => 1.5 * pi,
      (0f, y) => 0.5 * pi,
      (x, y) => atan(y / x)
    }
}
A 패턴에서 변할 수 있는 이름은 어떤 값과 일치하고, 그리고 분기의 행동 내부의 매치된 값의 값으로 대응된다. 그래서, (0f, y) matches 첫번째 요소는 0이고 두번째 요소로 y와 엮이는 어떤 튜플과 일치한다. (x, y)는 두 요소를 가진 어떤 튜플과 일치하고, 두 요소는 변수와 엮인다.

match 분기는 패턴과 일치하는 것을 찾은 뒤, 분기를 수행할지 말지 결정하는 bool 타입의 표현식인 패턴 가드라는 이름의 가드 구문(if EXPR라고 적히는)을 가질 수 있다. 패턴에 엮인 변수의 범위는 이 가드 표현식 안에 있다. angle 예제의 첫번째 분기는 패턴 가드의 예를 보여준다.

앞서 단순 let 바인딩을 이미 보았지만, let는 당신이 생각하는 것보다 더 근사하다. 또한 디스트럭처링 패턴을 지원한다. 예를 들어, 튜플로부터 필드의 두 변수 a와 b 를 한번에 추출하기위해 다음처럼 쓸 수 있다.

let (a, b) = get_tuple_of_two_ints();
Let 바인딩은 단지 반박할 수 없는 패턴만으로 동작한다. 즉, 매칭에 실패할 수 없는 패턴이다. 이것은 일치한 리터럴과 대부분의 enum 변형으로부터 let을 제외한다.

